---
title: "Predoc Data Task Analysis"
output:
  pdf_document:
    toc: true
    number_sections: true
    toc_depth: 3
header-includes:
  - \usepackage{hyperref}
  - \hypersetup{colorlinks=true,linkcolor=blue,urlcolor=blue,citecolor=blue}
---

```{r setup, include=FALSE}
# Required packages for this analysis and rendering.
required_packages <- c("readxl", "knitr", "rmarkdown", "stargazer", "formatR", "sandwich", "lmtest")

# Install any missing packages.
installed <- rownames(installed.packages())
missing <- setdiff(required_packages, installed)
if (length(missing) > 0) {
  install.packages(missing, repos = "https://cloud.r-project.org")
}

library(readxl)
library(knitr)
library(stargazer)
library(sandwich)
library(lmtest)

knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = TRUE,
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 80)
)

# Prevent LaTeX floats from drifting past their sections.
# Uses \clearpage to avoid extra package dependencies.
float_barrier <- function() {
  if (knitr::is_latex_output()) {
    cat("\\clearpage\n")
  }
}

# Use relative paths only (assumes project root is the working directory).
input_path <- file.path("Data - Winter 2026.xlsx")
output_dir <- file.path("output")

if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}
```

# 1. Load Data

```{r load-data}
# Load the main data sheet (raw data is treated as read-only).
data_raw <- readxl::read_excel(input_path, sheet = "Data")

# Explicitly require the variables that the plan allows us to analyze.
required_vars <- c(
  "ResponseId",
  "Finished",
  "passedattn",
  "consent",
  "IPAddress",
  "sex",
  "age",
  "real_imaginary",
  "blame_1",
  "outcome_binary1",
  "outcome_binary2"
)

# Fail loudly if any required variable is missing.
missing_vars <- setdiff(required_vars, names(data_raw))
if (length(missing_vars) > 0) {
  stop(paste("Missing required variables:", paste(missing_vars, collapse = ", ")))
}
```

# 2. Data Pipeline

## 2.1 Recoding and Missing Data Approach (Overview)

- This pipeline keeps `data_raw` read-only after import. There is no imputation of missing values.  
- Missing values would be handled by listwise deletion, if any existed. 
- In this dataset, post-recode missingness for core variables is 0.
  - Consequentially, no explicit missing-value exclusions are applied in the pipeline.

## 2.2 Eligibility Filters (Applied First)

```{r eligibility-filters}
# Exclusion flags follow the plan exactly.
# 1) Finished must be TRUE.
exclude_not_finished <- !(data_raw$Finished %in% TRUE)
# 2) Attention check must be "yes".
exclude_failed_attn <- !(data_raw$passedattn %in% "yes")
# 3) Consent must be AGREE (no explicit "do not use" flag exists).
exclude_nonconsent <- (!is.na(data_raw$consent)) & (data_raw$consent != "AGREE")

keep_eligible <- !(exclude_not_finished | exclude_failed_attn | exclude_nonconsent)
data_eligible <- data_raw[keep_eligible, ]

cat("Eligible rows after filters (Finished, attention, consent):", nrow(data_eligible), "\n")
```

## 2.3 Data Quality Checks (Review)

```{r data-quality-checks}
# Confirm each respondent appears once (ResponseId should be unique).
if (anyDuplicated(data_eligible$ResponseId) > 0) {
  dup_ids <- data_eligible$ResponseId[duplicated(data_eligible$ResponseId)]
  stop(paste("Duplicate ResponseId values found:", paste(unique(dup_ids), collapse = ", ")))
}

# Additional respondent uniqueness check using IP address (trimmed).
ip_norm <- trimws(as.character(data_eligible$IPAddress))
if (any(is.na(ip_norm) | ip_norm == "")) {
  stop("Missing IPAddress values found; cannot check uniqueness by IP address.")
}
if (anyDuplicated(ip_norm) > 0) {
  dup_ips <- unique(ip_norm[duplicated(ip_norm)])
  dup_counts <- table(ip_norm)[dup_ips]
  cat("Duplicate IPAddress values found (continuing):\n")
  cat("Total distinct duplicate IPs:", length(dup_ips), "\n")
  for (ip in dup_ips) {
    cat(" -", ip, "count:", as.integer(dup_counts[[ip]]), "\n")
  }

  # Print requested fields for all rows with duplicate IPs.
  extra_vars <- c(
    "IPAddress",
    "StartDate",
    "EndDate",
    "Duration (in seconds)",
    "Q26_Operating System",
    "describe"
  )
  missing_extra_vars <- setdiff(extra_vars, names(data_eligible))
  if (length(missing_extra_vars) > 0) {
    stop(paste("Missing required fields for duplicate IP review:",
               paste(missing_extra_vars, collapse = ", ")))
  }
  dup_rows <- data_eligible[ip_norm %in% dup_ips, extra_vars]

  # Table for timestamps, duration, and OS (plus IP for clarity).
  table_vars <- c(
    "IPAddress",
    "StartDate",
    "EndDate",
    "Duration (in seconds)",
    "Q26_Operating System"
  )
  dup_table <- dup_rows[, table_vars]
  cat("Duplicate IP rows (timestamps, duration, OS):\n")
  print(dup_table)

  # List of describe fields for each duplicate row.
  cat("Describe field entries for duplicate IP rows:\n")
  for (i in seq_len(nrow(dup_rows))) {
    desc_text <- as.character(dup_rows$describe[i])
    desc_text <- ifelse(is.na(desc_text), "[NA]", desc_text)
    wrapped_desc <- strwrap(desc_text, width = 80)
    cat(" - IP:", dup_rows$IPAddress[i], "Describe:\n")
    for (line in wrapped_desc) {
      cat("    ", line, "\n")
    }
  }
}

# After analyzing the duplicates, I've decided to keep them.
# The reasoning will be in the report appendix.

# Inventory variables used (plan requires an explicit list).
used_vars <- required_vars

# Helper: numeric summaries for ranges/missingness.
summarize_numeric <- function(x) {
  x_num <- as.numeric(x)
  if (all(is.na(x_num))) {
    return(list(n = length(x_num), missing = sum(is.na(x_num)), mean = NA, sd = NA, min = NA, max = NA))
  }
  list(
    n = length(x_num),
    missing = sum(is.na(x_num)),
    mean = mean(x_num, na.rm = TRUE),
    sd = sd(x_num, na.rm = TRUE),
    min = min(x_num, na.rm = TRUE),
    max = max(x_num, na.rm = TRUE)
  )
}

# Helper: categorical level inventory for observed values.
summarize_categorical <- function(x) {
  tab <- table(x, useNA = "ifany")
  as.data.frame(tab, stringsAsFactors = FALSE)
}

# Check for unexpected non-numeric entries in numeric fields.
count_non_numeric <- function(x) {
  x_num <- suppressWarnings(as.numeric(x))
  sum(!is.na(x) & is.na(x_num))
}

non_numeric_age <- count_non_numeric(data_eligible$age)
non_numeric_blame <- count_non_numeric(data_eligible$blame_1)

cat("Non-numeric entries (age):", non_numeric_age, "\n")
cat("Non-numeric entries (blame_1):", non_numeric_blame, "\n")

# Categorical variables to list levels for checks.
categorical_vars <- c("Finished", "passedattn", "consent", "sex", "real_imaginary", "outcome_binary1", "outcome_binary2")

# Numeric summaries for checks.
age_stats <- summarize_numeric(data_eligible$age)
blame_stats <- summarize_numeric(data_eligible$blame_1)

# Print key structure and quality checks in the knitted output.
cat("Data checks: total eligible rows:", nrow(data_eligible), "\n")
cat("Data checks: unique ResponseId rows:", nrow(data_eligible), "\n")
cat("Data checks: variables used:", paste(used_vars, collapse = ", "), "\n")
cat(
  "Data checks: age missing/mean/sd/min/max:",
  age_stats$missing,
  round(age_stats$mean, 2),
  round(age_stats$sd, 2),
  age_stats$min,
  age_stats$max,
  "\n"
)
cat(
  "Data checks: blame_1 missing/mean/sd/min/max:",
  blame_stats$missing,
  round(blame_stats$mean, 2),
  round(blame_stats$sd, 2),
  blame_stats$min,
  blame_stats$max,
  "\n"
)
cat("Data checks: observed levels for categorical variables:\n")
for (v in categorical_vars) {
  tab <- summarize_categorical(data_eligible[[v]])
  levels_text <- paste(tab$x, tab$Freq, sep = ": ", collapse = "; ")
  cat(" -", v, "->", levels_text, "\n")
}
```

## 2.4 Extreme Value Review (Ages)

```{r extreme-age-checks}
# We review extreme ages because Section 2.3 showed a max age of 149.
# Identify extreme ages for review (above 100 only).
extreme_mask <- !is.na(data_eligible$age) & (data_eligible$age > 100)
extreme_count <- sum(extreme_mask)

cat("Number of extreme ages (>100):", extreme_count, "\n")

# Show the full rows for extreme ages so decisions can be made explicitly.
t(data_eligible[extreme_mask, ])
```

## 2.5 Apply Extreme Value Decision

```{r remove-extreme-ages}
# Rule: keep ages <= 100; drop ages > 100 because the flagged row includes a "do not use" note.
data_no_extreme <- data_eligible[!extreme_mask, ]
cat("Rows dropped for age > 100:", nrow(data_eligible) - nrow(data_no_extreme), "\n")
```

## 2.6 Recode Outcomes and Controls

```{r recode}
# Decision: sex is the primary explanatory variable. Only "Female" and "Male" are valid.
allowed_sex <- c("Female", "Male")
if (any(!is.na(data_no_extreme$sex) & !(data_no_extreme$sex %in% allowed_sex))) {
  # bad_vals captures unexpected sex entries; we stop so they are not silently dropped or miscoded.
  bad_vals <- unique(data_no_extreme$sex[!is.na(data_no_extreme$sex) & !(data_no_extreme$sex %in% allowed_sex)])
  stop(paste("Unexpected values in sex:", paste(bad_vals, collapse = ", ")))
}

data_recoded <- data_no_extreme

# Set Female as the reference category for interpretation.
data_recoded$sex_factor <- factor(data_recoded$sex, levels = c("Female", "Male"))

# Decision: real_imaginary is used only as a control / robustness dimension.
real_label <- "I have thought of a real argument/conflict from my life where this is true"
imag_label <- "I am imagining myself in a fictional situation where this is true (I can't think of one from my own life)"

allowed_real_imag <- c(real_label, imag_label)
if (any(!is.na(data_recoded$real_imaginary) & !(data_recoded$real_imaginary %in% allowed_real_imag))) {
  # bad_vals captures unexpected framing entries; we stop rather than coerce to avoid misclassification.
  bad_vals <- unique(data_recoded$real_imaginary[!is.na(data_recoded$real_imaginary) & !(data_recoded$real_imaginary %in% allowed_real_imag)])
  stop(paste("Unexpected values in real_imaginary:", paste(bad_vals, collapse = ", ")))
}

# Map to concise labels for modeling.
data_recoded$real_imaginary_factor <- factor(
  ifelse(data_recoded$real_imaginary == real_label, "real",
         ifelse(data_recoded$real_imaginary == imag_label, "imagined", NA)),
  levels = c("real", "imagined")
)

# Decision: outcome coding (1 = "I apologize first...", 0 = "Neither apologizes").
ob1_yes <- "I apologize first, then ${e://Field/initials} apologizes."
ob1_no <- "Neither I nor ${e://Field/initials} apologizes."

ob2_yes <- "I apologize first, but ${e://Field/initials} does not apologize after that."
ob2_no <- "Neither I nor ${e://Field/initials} apologizes."

if (any(!is.na(data_recoded$outcome_binary1) & !(data_recoded$outcome_binary1 %in% c(ob1_yes, ob1_no)))) {
  # bad_vals captures outcome responses outside the two allowed strings; we stop to prevent miscoding.
  bad_vals <- unique(data_recoded$outcome_binary1[!is.na(data_recoded$outcome_binary1) & !(data_recoded$outcome_binary1 %in% c(ob1_yes, ob1_no))])
  stop(paste("Unexpected values in outcome_binary1:", paste(bad_vals, collapse = ", ")))
}
if (any(!is.na(data_recoded$outcome_binary2) & !(data_recoded$outcome_binary2 %in% c(ob2_yes, ob2_no)))) {
  # bad_vals captures outcome responses outside the two allowed strings; we stop to prevent miscoding.
  bad_vals <- unique(data_recoded$outcome_binary2[!is.na(data_recoded$outcome_binary2) & !(data_recoded$outcome_binary2 %in% c(ob2_yes, ob2_no))])
  stop(paste("Unexpected values in outcome_binary2:", paste(bad_vals, collapse = ", ")))
}

# Create numeric outcomes for analysis and plotting.
data_recoded$outcome1 <- ifelse(data_recoded$outcome_binary1 == ob1_yes, 1,
                                ifelse(data_recoded$outcome_binary1 == ob1_no, 0, NA))

data_recoded$outcome2 <- ifelse(data_recoded$outcome_binary2 == ob2_yes, 1,
                                ifelse(data_recoded$outcome_binary2 == ob2_no, 0, NA))

```

## 2.7 Missingness After Recoding (Post-Filters)

```{r post-recode-missingness}
# Missingness for analysis variables after eligibility filters and extreme-age drop.
vars_for_missing <- c(
  "sex",
  "age",
  "real_imaginary",
  "blame_1",
  "outcome_binary1",
  "outcome_binary2",
  "outcome1",
  "outcome2"
)

missing_post_recode <- sapply(data_recoded[vars_for_missing], function(x) sum(is.na(x)))
missing_table <- data.frame(
  variable = names(missing_post_recode),
  missing_count = as.integer(missing_post_recode),
  stringsAsFactors = FALSE
)

if (knitr::is_latex_output()) {
  knitr::kable(missing_table, format = "latex",
               caption = "Missingness after filters, extreme-age drop, and recoding")
} else {
  knitr::kable(missing_table, format = "html",
               caption = "Missingness after filters, extreme-age drop, and recoding")
}
float_barrier()
```

## 2.8 Final Sample Construction and Flow Table

```{r sample-construction}
analysis_main <- data_recoded

# Only keep needed columns for analysis and output.
analysis_vars <- c(
  "ResponseId",
  "sex_factor",
  "age",
  "real_imaginary_factor",
  "blame_1",
  "outcome1",
  "outcome2"
)
analysis_main <- analysis_main[, analysis_vars]

# Save cleaned analysis dataset to /output (raw data remains untouched).
clean_path <- file.path(output_dir, "cleaned_analysis_data.csv")
write.csv(analysis_main, clean_path, row.names = FALSE)

sample_flow <- data.frame(
  step = c(
    "raw",
    "after_eligibility_filters",
    "after_extreme_age_drop"
  ),
  n = c(
    nrow(data_raw),
    nrow(data_eligible),
    nrow(data_no_extreme)
  ),
  stringsAsFactors = FALSE
)

if (knitr::is_latex_output()) {
  knitr::kable(sample_flow, format = "latex", caption = "Sample flow counts")
} else {
  knitr::kable(sample_flow, format = "html", caption = "Sample flow counts")
}
float_barrier()
```

# 3. Descriptive Statistics

```{r descriptives}
# Descriptive table: mean, median, SD by sex group (overall, female, male).
# Includes age, outcomes, real_imaginary (coded 1=real, 0=imagined), and blame_1.
if (!is.numeric(analysis_main$blame_1)) {
  stop("blame_1 must be numeric to compute mean/median/SD. Check the raw data coding.")
}

analysis_main$real_binary <- ifelse(analysis_main$real_imaginary_factor == "real", 1,
                                    ifelse(analysis_main$real_imaginary_factor == "imagined", 0, NA))

stats_by_group <- function(x, group_name) {
  data.frame(
    group = group_name,
    mean = mean(x, na.rm = TRUE),
    median = median(x, na.rm = TRUE),
    sd = sd(x, na.rm = TRUE)
  )
}

build_desc_table <- function(var_name, x, data) {
  rbind(
    cbind(variable = var_name, stats_by_group(x, "Overall")),
    cbind(variable = var_name, stats_by_group(x[data$sex_factor == "Female"], "Female")),
    cbind(variable = var_name, stats_by_group(x[data$sex_factor == "Male"], "Male"))
  )
}

desc_table <- rbind(
  build_desc_table("age", analysis_main$age, analysis_main),
  build_desc_table("outcome1", analysis_main$outcome1, analysis_main),
  build_desc_table("outcome2", analysis_main$outcome2, analysis_main),
  build_desc_table("real_imaginary_real", analysis_main$real_binary, analysis_main),
  build_desc_table("blame_1", analysis_main$blame_1, analysis_main)
)

if (knitr::is_latex_output()) {
  knitr::kable(desc_table, digits = 3, format = "latex",
               caption = "Descriptive statistics by sex (mean, median, SD)")
} else {
  knitr::kable(desc_table, digits = 3, format = "html",
               caption = "Descriptive statistics by sex (mean, median, SD)")
}
float_barrier()
```

```{r sex-counts}
# Print simple sex counts
sex_counts <- table(analysis_main$sex_factor, useNA = "ifany")

cat(sprintf("Sex counts:  Female: %d, Male: %d\n",
            sex_counts["Female"],
            sex_counts["Male"]))

```

```{r real-imag-counts}
# Print simple real/imaginary counts
ri_counts <- table(analysis_main$real_imaginary_factor, useNA = "ifany")

cat(sprintf("Conflict counts: Real: %d, Imagined: %d\n",
            ri_counts["real"],
            ri_counts["imagined"]))
  
```

# 4. Main Analysis

```{r diff-in-means}
# Difference-in-means (Male minus Female) with 95% CI and p-values.
# Test choice: t.test() compares group means directly and is valid for binary outcomes as a difference-in-means test.
# Justification: this aligns with the linear probability model interpretation and keeps the contrast on the mean scale.
diff_in_means <- function(outcome_var, outcome_name) {
  male <- analysis_main[analysis_main$sex_factor == "Male", ]
  female <- analysis_main[analysis_main$sex_factor == "Female", ]

  mean_m <- mean(male[[outcome_var]], na.rm = TRUE)
  mean_f <- mean(female[[outcome_var]], na.rm = TRUE)

  test <- t.test(male[[outcome_var]], female[[outcome_var]])

  data.frame(
    outcome = outcome_name,
    mean_male = mean_m,
    mean_female = mean_f,
    diff_male_minus_female = mean_m - mean_f,
    ci_lower = test$conf.int[1],
    ci_upper = test$conf.int[2],
    p_value = test$p.value
  )
}

dim1 <- diff_in_means("outcome1", "outcome_binary1")
dim2 <- diff_in_means("outcome2", "outcome_binary2")

diff_table <- rbind(dim1, dim2)
if (knitr::is_latex_output()) {
  knitr::kable(diff_table, digits = 4, format = "latex",
               caption = "Difference-in-means (Male - Female)")
} else {
  knitr::kable(diff_table, digits = 4, format = "html",
               caption = "Difference-in-means (Male - Female)")
}
float_barrier()
```

```{r graph-1, fig.cap="Conciliation by Sex with 95% CIs", fig.width=7, fig.height=3.5, fig.path=tempdir(), dev="png"}
# Figure 1: Two-panel bar chart of outcome rates by sex with 95% CI error bars.
# Panel A: Reciprocal conciliation (outcome1).
# Panel B: Unilateral conciliation (outcome2).
# CI method: exact binomial confidence interval from binom.test().

compute_rate_ci <- function(x, group) {
  x_group <- x[group]
  n <- sum(!is.na(x_group))
  if (n == 0) {
    return(c(rate = NA_real_, lower = NA_real_, upper = NA_real_))
  }
  successes <- sum(x_group == 1, na.rm = TRUE)
  ci <- binom.test(successes, n)$conf.int
  c(rate = successes / n, lower = ci[1], upper = ci[2])
}

plot_rate_with_ci <- function(rate_ci, title_text) {
  bar_pos <- barplot(
    height = rate_ci["rate", ],
    names.arg = c("Female", "Male"),
    ylim = c(0, 1),
    main = title_text,
    ylab = "Proportion",
    xlab = ""
  )
  arrows(
    x0 = bar_pos,
    y0 = rate_ci["lower", ],
    x1 = bar_pos,
    y1 = rate_ci["upper", ],
    angle = 90,
    code = 3,
    length = 0.05
  )
}

sex_is_female <- analysis_main$sex_factor == "Female"
sex_is_male <- analysis_main$sex_factor == "Male"

rate_ci_outcome1 <- cbind(
  Female = compute_rate_ci(analysis_main$outcome1, sex_is_female),
  Male = compute_rate_ci(analysis_main$outcome1, sex_is_male)
)
rate_ci_outcome2 <- cbind(
  Female = compute_rate_ci(analysis_main$outcome2, sex_is_female),
  Male = compute_rate_ci(analysis_main$outcome2, sex_is_male)
)

draw_figure_1 <- function(add_caption) {
  op <- par(no.readonly = TRUE)
  on.exit(par(op), add = TRUE)
  par(mfrow = c(1, 2), mar = c(4, 4, 3, 1), oma = c(2, 0, 0, 0),
      cex.main = 0.9, family = "serif")
  plot_rate_with_ci(rate_ci_outcome1, "Reciprocal conciliation by sex")
  plot_rate_with_ci(rate_ci_outcome2, "Unilateral conciliation by sex")
  if (add_caption) {
    mtext("Figure 1: Conciliation by Sex with 95% CIs",
          side = 1, outer = TRUE, line = 1, cex = 0.9)
  }
}

# Render for the knitted output (caption handled by fig.cap in PDF).
draw_figure_1(add_caption = FALSE)

# Also write a captioned PNG for the output folder.
png(filename = file.path(output_dir, "figure_1_conciliation.png"),
    width = 7, height = 3.5, units = "in", res = 300)
draw_figure_1(add_caption = TRUE)
dev.off()

float_barrier()
```

```{r regressions}
# Main LPMs: outcome ~ sex + age (listwise deletion occurs naturally).
# Model choice: linear probability models are used as the main specification.
# Justification: LPM coefficients are directly interpretable as percentage-point changes in probability, which
# is the most transparent way to answer the research question in this short data task.
reg_main_out1 <- lm(outcome1 ~ sex_factor + age, data = analysis_main)
reg_main_out2 <- lm(outcome2 ~ sex_factor + age, data = analysis_main)

# Helper: HC3 robust standard error and p-value for a coefficient.
robust_coef_stats <- function(model, term) {
  vc <- sandwich::vcovHC(model, type = "HC3")
  ct <- lmtest::coeftest(model, vcov. = vc)
  if (!(term %in% rownames(ct))) {
    stop(paste("Term not found in model coefficients:", term))
  }
  list(
    estimate = ct[term, "Estimate"],
    se = ct[term, "Std. Error"],
    p = ct[term, "Pr(>|t|)"]
  )
}

```

```{r stargazer-main-lpm, results='asis', comment=NA, echo=TRUE}
# Main results table (stargazer) for Section 4.
stargazer(
  reg_main_out1,
  reg_main_out2,
  type = if (knitr::is_latex_output()) "latex" else "html",
  title = "Main LPM Regressions",
  label = if (knitr::is_latex_output()) "tab:main_lpm" else NULL,
  header = FALSE,
  float = TRUE,
  table.placement = "htbp",
  se = list(
    sqrt(diag(sandwich::vcovHC(reg_main_out1, type = "HC3"))),
    sqrt(diag(sandwich::vcovHC(reg_main_out2, type = "HC3")))
  ),
  dep.var.labels = c("Outcome 1", "Outcome 2"),
  covariate.labels = c("Male", "Age"),
  keep.stat = c("n"),
  digits = 3
)
float_barrier()
```

# 5. Robustness Checks

```{r robustness}

# Influence/leverage check (concise): drop the single most influential observation and re-estimate.
# Diagnostic used: Cook's distance from the main LPM to identify the most influential row.
# Purpose: assess whether the main sex effect is sensitive to one high-leverage observation in a small sample.
refit_drop_top_influence <- function(model, data, label) {
  cooks <- cooks.distance(model)
  drop_idx <- which.max(cooks)
  refit <- lm(formula(model), data = data[-drop_idx, ])
  orig_stats <- robust_coef_stats(model, "sex_factorMale")
  refit_stats <- robust_coef_stats(refit, "sex_factorMale")
  se_orig <- orig_stats$se
  p_orig <- orig_stats$p
  se_refit <- refit_stats$se
  p_refit <- refit_stats$p
  coef_orig <- orig_stats$estimate
  coef_refit <- refit_stats$estimate
  coef_diff <- abs(coef_refit - coef_orig)
  se_diff <- abs(se_refit - se_orig)
  p_diff <- abs(p_refit - p_orig)
  cat("\nInfluence check:", label, "\n")
  cat("Diagnostic: Cook's distance (drop the single largest value).\n")
  cat("Dropped row index:", drop_idx, "\n")
  cat("Sex coefficient (original, refit):",
      round(coef_orig, 3), "->",
      round(coef_refit, 3), "\n")
  cat("SE (original, refit):",
      round(se_orig, 3), "->",
      round(se_refit, 3), "\n")
  cat("p-value (original, refit):",
      round(p_orig, 3), "->",
      round(p_refit, 3), "\n")
  cat(
    "Change summary (absolute): coef=", round(coef_diff, 3),
    ", SE=", round(se_diff, 3),
    ", p-value=", round(p_diff, 3), "\n"
  )
}

refit_drop_top_influence(reg_main_out1, analysis_main, "Main LPM - Outcome 1")
refit_drop_top_influence(reg_main_out2, analysis_main, "Main LPM - Outcome 2")

# Control robustness: add real_imaginary to the main specification.
# Justification: the plan specifies real/imaginary as a control or sample dimension; adding it tests whether
# the main sex effect is sensitive to framing.
reg_main_out1_real <- lm(outcome1 ~ sex_factor + age + real_imaginary_factor, data = analysis_main)
reg_main_out2_real <- lm(outcome2 ~ sex_factor + age + real_imaginary_factor, data = analysis_main)

# Control robustness: add blame_1 to the main specification.
# Justification: tests whether results are sensitive to including perceived blame as an additional control.
# blame_1: higher values indicate more blame assigned to the respondent
# lower values indicate more blame assigned to the other person.
reg_main_out1_blame <- lm(outcome1 ~ sex_factor + age + blame_1, data = analysis_main)
reg_main_out2_blame <- lm(outcome2 ~ sex_factor + age + blame_1, data = analysis_main)

# Across regressions, the gender effect remains small and non-significant.
```

```{r stargazer-robustness, results='asis', comment=NA, echo=TRUE}
# Robustness regression table (stargazer) comparing main spec to each check.
robust_models <- list(
  reg_main_out1,
  reg_main_out1_real,
  reg_main_out1_blame,
  reg_main_out2,
  reg_main_out2_real,
  reg_main_out2_blame
)

stargazer(
  robust_models,
  type = if (knitr::is_latex_output()) "latex" else "html",
  title = "Robustness Regressions (Main + Controls)",
  label = if (knitr::is_latex_output()) "tab:robustness" else NULL,
  header = FALSE,
  float = TRUE,
  table.placement = "htbp",
  object.names = FALSE,
  se = lapply(robust_models, function(m) sqrt(diag(sandwich::vcovHC(m, type = "HC3")))),
  dep.var.labels = c("Outcome 1", "Outcome 2"),
  column.separate = c(3, 3),
  covariate.labels = c("Male", "Age", "Imagined (ref: Real)", "Blame"),
  keep.stat = c("n"),
  digits = 3
)
float_barrier()
```

# 6. Exploratory: Blame - Sex Interaction

```{r blame-sex-interaction, results='asis', comment=NA, echo=TRUE}
# Exploratory check: interaction between blame_1 and sex.
# Model includes main effects plus interaction, with age as a control.
reg_int_out1 <- lm(outcome1 ~ sex_factor * blame_1 + age, data = analysis_main)
reg_int_out2 <- lm(outcome2 ~ sex_factor * blame_1 + age, data = analysis_main)

stargazer(
  reg_int_out1,
  reg_int_out2,
  type = if (knitr::is_latex_output()) "latex" else "html",
  title = "Exploratory Interaction: Sex * Blame",
  label = if (knitr::is_latex_output()) "tab:interaction" else NULL,
  se = list(
    sqrt(diag(sandwich::vcovHC(reg_int_out1, type = "HC3"))),
    sqrt(diag(sandwich::vcovHC(reg_int_out2, type = "HC3")))
  ),
  dep.var.labels = c("Outcome 1", "Outcome 2"),
  covariate.labels = c("Male", "Blame", "Male * Blame", "Age"),
  keep.stat = c("n"),
  digits = 3,
  header = FALSE,
  float = TRUE,
  table.placement = "htbp"
)
float_barrier()
```
